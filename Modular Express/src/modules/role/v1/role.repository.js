// role.repository.js
import oracledb from 'oracledb'
import RoleSchema from './role.schema.js'
import Role from './role.model.js'

/**
 * Репозиторій для роботи з таблицею APP_ROLES в Oracle.
 * Використовує RoleSchema для динамічної побудови запитів.
 */
class RoleRepository {
    constructor(dbConnection) {
        this.db = dbConnection // Передається через DI (модуль)
    }

    /**
     * Створює таблицю, якщо вона відсутня в Oracle.
     */
    async initializeSchema() {
        const tableName = RoleSchema.table.toUpperCase()
        const cols = RoleSchema.columns

        // Перевіряємо існування таблиці в системному каталозі Oracle
        const checkTable = await this.db.execute(
            `SELECT table_name FROM user_tables WHERE table_name = :tableName`,
            { tableName },
        )

        if (checkTable.rows.length === 0) {
            console.log(`[Database] Creating table ${tableName}...`)

            const createSql = `
        CREATE TABLE ${tableName} (
          ${cols.id.name} NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          ${cols.name.name} VARCHAR2(50) NOT NULL UNIQUE,
          ${cols.description.name} VARCHAR2(255),
          ${cols.internalCode.name} VARCHAR2(20),
          CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
      `

            await this.db.execute(createSql)
            console.log(`[Database] Table ${tableName} created successfully.`)

            // ПІСЛЯ створення таблиці робимо Seeding
            const countResult = await this.db.execute(`SELECT COUNT(*) as cnt FROM ${tableName}`)
            if (countResult.rows[0].CNT === 0) {
                console.log(`[Database] Seeding default roles...`)

                const roles = [
                    { id: 1, name: 'ADMIN', desc: 'System Administrator' },
                    { id: 2, name: 'USER', desc: 'Regular User' },
                ]

                const insertSql = `INSERT INTO ${tableName}
      (${RoleSchema.columns.id.name}, ${RoleSchema.columns.name.name}, ${RoleSchema.columns.description.name})
      VALUES (:id, :name, :desc)`

                await this.db.executeMany(insertSql, roles, { autoCommit: true })
            }
        }
    }

    /**
     * Знайти всі ролі
     * @returns {Promise<Role[]>}
     */
    async findAll() {
        const query = `SELECT * FROM ${RoleSchema.table}`
        const result = await this.db.execute(query, [], { outFormat: oracledb.OUT_FORMAT_OBJECT })

        return result.rows.map((row) => Role.fromDatabase(row))
    }

    /**
     * Знайти роль за ID
     * @param {number} id
     * @returns {Promise<Role|null>}
     */
    async findById(id) {
        const pkColumn = Object.values(RoleSchema.columns).find((col) => col.isPrimaryKey).name
        const query = `SELECT * FROM ${RoleSchema.table} WHERE ${pkColumn} = :id`

        const result = await this.db.execute(
            query,
            { id },
            { outFormat: oracledb.OUT_FORMAT_OBJECT },
        )

        if (result.rows.length === 0) return null
        return Role.fromDatabase(result.rows[0])
    }

    /**
     * Створити нову роль
     * @param {Role} role
     */
    async create(role) {
        const dbData = role.toDatabaseNames()
        const columns = Object.keys(dbData).join(', ')
        const binds = Object.keys(dbData)
            .map((key) => `:${key}`)
            .join(', ')

        const query = `INSERT INTO ${RoleSchema.table} (${columns}) VALUES (${binds})`

        await this.db.execute(query, dbData, { autoCommit: true })
        return role
    }

    /**
     * Оновити існуючу роль
     * @param {number} id
     * @param {Partial<Role>} roleData
     */
    async update(id, roleData) {
        const pkColumn = Object.values(RoleSchema.columns).find((col) => col.isPrimaryKey).name

        // Створюємо екземпляр моделі, щоб отримати коректні назви колонок
        const model = new Role(roleData)
        const dbData = model.toDatabaseNames()

        // Формуємо рядок SET для SQL, ігноруючи PK в самому SET
        const setClause = Object.keys(dbData)
            .filter((colName) => colName !== pkColumn)
            .map((colName) => `${colName} = :${colName}`)
            .join(', ')

        const query = `UPDATE ${RoleSchema.table} SET ${setClause} WHERE ${pkColumn} = :id`

        const result = await this.db.execute(query, { ...dbData, id }, { autoCommit: true })

        return result.rowsAffected > 0
    }

    /**
     * Видалити роль
     * @param {number} id
     */
    async delete(id) {
        const pkColumn = Object.values(RoleSchema.columns).find((col) => col.isPrimaryKey).name
        const query = `DELETE FROM ${RoleSchema.table} WHERE ${pkColumn} = :id`

        const result = await this.db.execute(query, { id }, { autoCommit: true })

        return result.rowsAffected > 0
    }
}

export default RoleRepository
