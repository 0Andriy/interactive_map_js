// auth.repository.js
import oracledb from 'oracledb'
import AuthSchema from './auth.schema.js'

/**
 * Репозиторій для управління сесіями користувачів в Oracle.
 */
class AuthRepository {
    /**
     * @param {Object} db - Oracle Connection
     */
    constructor(db) {
        this.db = db
    }

    /**
     * Створює таблицю сесій та індекси, якщо вони відсутні.
     */
    async initializeSchema() {
        const tableName = AuthSchema.table.toUpperCase()
        const cols = AuthSchema.columns

        // 1. Перевіряємо існування таблиці
        const checkTable = await this.db.execute(
            `SELECT table_name FROM user_tables WHERE table_name = :tableName`,
            { tableName },
        )

        if (checkTable.rows.length === 0) {
            console.log(`[Database] Creating table ${tableName}...`)

            const createSql = `
        CREATE TABLE ${tableName} (
          ${cols.id.name} NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          ${cols.userId.name} NUMBER NOT NULL,
          ${cols.token.name} VARCHAR2(1000) NOT NULL,
          ${cols.refreshToken.name} VARCHAR2(1000),
          ${cols.expiresAt.name} TIMESTAMP NOT NULL,
          ${cols.ipAddress.name} VARCHAR2(45),
          ${cols.createdAt.name} TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          CONSTRAINT fk_auth_user FOREIGN KEY (${cols.userId.name})
            REFERENCES APP_USERS(USER_ID) ON DELETE CASCADE
        )
      `

            await this.db.execute(createSql)

            // 2. Створюємо індекс для прискорення пошуку за токеном (використовується при кожному запиті)
            await this.db.execute(
                `CREATE INDEX idx_auth_token ON ${tableName} (${cols.token.name})`,
            )

            console.log(`[Database] Table ${tableName} and indexes created.`)
        }
    }

    /**
     * Зберегти нову сесію
     * @param {Object} sessionData
     */
    async saveSession(sessionData) {
        const cols = AuthSchema.columns
        const query = `
      INSERT INTO ${AuthSchema.table} (
        ${cols.userId.name},
        ${cols.token.name},
        ${cols.refreshToken.name},
        ${cols.expiresAt.name},
        ${cols.ipAddress.name}
      ) VALUES (:userId, :token, :refreshToken, :expiresAt, :ipAddress)
    `

        await this.db.execute(
            query,
            {
                userId: sessionData.userId,
                token: sessionData.token,
                refreshToken: sessionData.refreshToken,
                expiresAt: sessionData.expiresAt, // Передаємо як об'єкт Date
                ipAddress: sessionData.ipAddress,
            },
            { autoCommit: true },
        )
    }

    /**
     * Знайти сесію за будь-яким типом токена
     * @param {string} tokenValue
     */
    async findSessionByAnyToken(tokenValue) {
        const cols = AuthSchema.columns
        const query = `
    SELECT * FROM ${AuthSchema.table}
    WHERE (${cols.token.name} = :token OR ${cols.refreshToken.name} = :token)
    AND ${cols.expiresAt.name} > CURRENT_TIMESTAMP
  `

        const result = await this.db.execute(
            query,
            { token: tokenValue },
            {
                outFormat: oracledb.OUT_FORMAT_OBJECT,
            },
        )

        return result.rows[0] || null
    }

    /**
     * Перевірити наявність токена в базі
     * @param {string} token
     */
    async findSessionByToken(token) {
        const query = `
      SELECT * FROM ${AuthSchema.table}
      WHERE ${AuthSchema.columns.token.name} = :token
      AND ${AuthSchema.columns.expiresAt.name} > CURRENT_TIMESTAMP
    `

        const result = await this.db.execute(
            query,
            { token },
            {
                outFormat: oracledb.OUT_FORMAT_OBJECT,
            },
        )

        return result.rows[0] || null
    }

    /**
     * Видалити сесію (Logout)
     * @param {string} token
     */
    async deleteSession(token) {
        const query = `
      DELETE FROM ${AuthSchema.table}
      WHERE ${AuthSchema.columns.token.name} = :token
    `

        const result = await this.db.execute(query, { token }, { autoCommit: true })
        return result.rowsAffected > 0
    }

    /**
     * Видалити всі сесії користувача (наприклад, при зміні пароля)
     */
    async deleteAllUserSessions(userId) {
        const query = `
      DELETE FROM ${AuthSchema.table}
      WHERE ${AuthSchema.columns.userId.name} = :userId
    `

        await this.db.execute(query, { userId }, { autoCommit: true })
    }
}

export default AuthRepository
