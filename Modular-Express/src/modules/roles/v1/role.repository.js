import { RoleSchema } from './role.schema.js'
import { Role } from './role.model.js'
import { getContext } from '../../../common/utils/context.js'

/**
 * Репозиторій для роботи з таблицею APP_ROLES в Oracle.
 * Використовує RoleSchema для динамічної побудови запитів.
 * Реалізує CRUD операції та ініціалізацію схеми.
 */
export class RoleRepository {
    /**
     * @param {Object} db - Інстанс підключення до бази даних.
     */
    constructor(db) {
        this.db = db
        /** @type {string} Назва колонки первинного ключа */
        this.pkColumn = Object.values(RoleSchema.columns).find((col) => col.isPrimaryKey).name
    }

    /**
     * Отримує екзекутор БД на основі поточного контексту.
     * @private
     * @returns {Promise<Object>} Об'єкт підключення до конкретної БД.
     * @throws {Error} Якщо контекст бази даних відсутній.
     */
    async _getExecutor() {
        const { dbName } = getContext()
        if (!dbName) throw new Error('Database context (dbName) is missing')
        return await this.db.get(dbName)
    }

    /**
     * Автоматично визначає тип BIND для Oracle.
     * @private
     */
    _getOracleType(db, colName) {
        const colNameUpper = colName.toUpperCase()
        // Дати та Timestamp
        if (colNameUpper.includes('DATE') || colNameUpper.includes('AT')) {
            return db.oracledb.DATE
        }
        // Числа (ID)
        const colConfig = Object.values(RoleSchema.columns).find((c) => c.name === colName)
        if (colConfig?.isPrimaryKey || colNameUpper.includes('ID')) {
            return db.oracledb.NUMBER
        }
        // Все інше - рядки
        return db.oracledb.STRING
    }

    /**
     * Перетворює вихідні масиви Oracle outBinds у чистий об'єкт моделі.
     * @private
     */
    _mapOutBindsToModel(outBinds, columns) {
        const freshData = {}
        columns.forEach((colName) => {
            const val = outBinds[`out_${colName}`]
            // Oracle BIND_OUT завжди повертає масив, беремо перший елемент [0]
            freshData[colName] = Array.isArray(val) ? val[0] : val
        })
        return Role.fromDatabase(freshData)
    }

    /**
     * Перевіряє існування таблиці, створює її та заповнює початковими даними за потреби.
     * @returns {Promise<void>}
     */
    async initializeSchema() {
        const db = await this._getExecutor()

        const tableName = RoleSchema.table.toUpperCase()
        const cols = RoleSchema.columns

        // Перевіряємо існування таблиці в системному каталозі Oracle
        const isExistSql = `SELECT table_name FROM user_tables WHERE table_name = :tableName`
        const checkTable = await db.execute(isExistSql, { tableName })

        if (checkTable.rows.length === 0) {
            console.log(`[Database] Creating table ${tableName}...`)

            const createSql = `
                CREATE TABLE ${tableName} (
                ${cols.id.name} NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                ${cols.name.name} VARCHAR2(50) NOT NULL UNIQUE,
                ${cols.description.name} VARCHAR2(255),
                CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            `

            await db.execute(createSql)
            console.log(`[Database] Table ${tableName} created successfully.`)

            // ПІСЛЯ створення таблиці робимо Seeding
            const countResult = await db.execute(`SELECT COUNT(*) as cnt FROM ${tableName}`)
            if (countResult.rows[0].CNT === 0) {
                console.log(`[Database] Seeding default roles...`)

                const roles = [
                    { id: 1, name: 'ADMIN', description: 'System Administrator' },
                    { id: 2, name: 'USER', description: 'Regular User' },
                ]

                const bindDefs = {
                    id: { type: db.oracledb.NUMBER },
                    name: { type: db.oracledb.STRING, maxSize: 20 },
                    description: { type: db.oracledb.STRING, maxSize: 100 },
                }

                const insertSql = `
                    INSERT INTO ${tableName}
                    (${RoleSchema.columns.id.name}, ${RoleSchema.columns.name.name}, ${RoleSchema.columns.description.name})
                    VALUES (:id, :name, :description)
                `

                await db.executeMany(insertSql, roles, { bindDefs })
            }
        }
    }

    /**
     * Знаходить роль за її ідентифікатором.
     * @param {number|string} id - ID ролі.
     * @returns {Promise<Role|null>} Об'єкт Role або null, якщо не знайдено.
     */
    async findById(id) {
        const db = await this._getExecutor()

        const pkColumn = Object.values(RoleSchema.columns).find((col) => col.isPrimaryKey).name
        const query = `SELECT * FROM ${RoleSchema.table} WHERE ${pkColumn} = :id`

        const result = await db.execute(query, { id })

        if (result.rows && result.rows.length === 0) return null
        return Role.fromDatabase(result.rows[0])
    }

    /**
     * Знаходить декілька ролей за масивом ідентифікаторів.
     * @param {Array<number|string>} ids - Список ID.
     * @returns {Promise<Role[]>} Масив знайдених об'єктів Role.
     */
    async findByIds(ids) {
        if (!ids?.length) return []

        const db = await this._getExecutor()

        const pkColumn = Object.values(RoleSchema.columns).find((col) => col.isPrimaryKey).name

        // Генеруємо плейсхолдери :id0, :id1...
        const binds = {}
        const placeholders = ids
            .map((id, index) => {
                const key = `id${index}`
                binds[key] = id
                return `:${key}`
            })
            .join(', ')

        const query = `SELECT * FROM ${RoleSchema.table} WHERE ${pkColumn} IN (${placeholders})`

        const result = await db.execute(query, binds)

        return result.rows.map((row) => Role.fromDatabase(row))
    }

    /**
     * Пошук ролей за фільтрами (рівність значень).
     * @param {Object} [filters={}] - Об'єкт з фільтрами { COLUMN_NAME: value }.
     * @returns {Promise<Role[]>} Масив знайдених ролей.
     */
    async find(filters = {}) {
        const db = await this._getExecutor()

        const whereClauses = Object.keys(filters).map((col) => `${col} = :${col}`)
        const whereSql = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : ''

        const sql = `SELECT * FROM ${RoleSchema.table} ${whereSql}`

        const result = await db.execute(sql, filters)

        return result.rows.map((row) => Role.fromDatabase(row))
    }

    async findByName(name) {
        const db = await this._getExecutor()
        const colName = RoleSchema.columns.name.name
        const query = `SELECT * FROM ${RoleSchema.table} WHERE ${colName} = :name`

        const result = await db.execute(query, { name })
        return result.rows?.length ? Role.fromDatabase(result.rows[0]) : null
    }

    // -------------------------------

    /**
     * Валідація назви колонки
     */
    _validateColumn(colName) {
        if (!this.allowedColumns.includes(colName.toUpperCase())) {
            throw new Error(
                `Invalid column name: ${colName}. Allowed columns: ${this.allowedColumns.join(', ')}`,
            )
        }
    }

    /**
     * Рекурсивний конструктор WHERE з валідацією
     */
    _buildWhereClause(filters, initialBindIdx = 0) {
        const binds = {}
        let bindIdx = initialBindIdx

        const processGroup = (group) => {
            if (!group || !group.criteria || group.criteria.length === 0) return ''

            const clauses = group.criteria.map((item) => {
                if (item.criteria) return `(${processGroup(item)})`

                const { col, op, val } = item
                this._validateColumn(col) // ВАЛІДАЦІЯ ТУТ

                const opUpper = op.toUpperCase()
                if (opUpper === 'IS NULL') return `${col} IS NULL`
                if (opUpper === 'IS NOT NULL') return `${col} IS NOT NULL`

                const bName = `p${bindIdx++}`

                if (opUpper === 'IN') {
                    if (!Array.isArray(val))
                        throw new Error('Value for IN operator must be an array')
                    const inPlaceholders = val
                        .map((v, i) => {
                            const inBName = `${bName}_${i}`
                            binds[inBName] = v
                            return `:${inBName}`
                        })
                        .join(', ')
                    return `${col} IN (${inPlaceholders})`
                }

                binds[bName] = val
                return `${col} ${op} :${bName}`
            })

            const logicalOperator = group.logical?.toUpperCase() === 'OR' ? 'OR' : 'AND'
            return clauses.join(` ${logicalOperator} `)
        }

        const sql = processGroup(filters)
        return { sql: sql ? `WHERE ${sql}` : '', binds, nextBindIdx: bindIdx }
    }

    /**
     * Повний метод find з підтримкою всіх фіч
     */
    async findAdvance({
        filters = { logical: 'AND', criteria: [] },
        orderBy = [],
        pagination = null,
    } = {}) {
        const db = await this._getExecutor()

        let { sql: whereSql, binds } = this._buildWhereClause(filters)

        // Додаткова логіка курсора
        if (pagination?.type === 'cursor' && pagination.lastId) {
            const cursorOp = pagination.direction === 'prev' ? '<' : '>'
            whereSql = whereSql
                ? `${whereSql} AND ID ${cursorOp} :lastId`
                : `WHERE ID ${cursorOp} :lastId`
            binds.lastId = pagination.lastId
        }

        // Сортування з валідацією
        let orderSql = 'ORDER BY 1'
        if (orderBy.length > 0) {
            const orderParts = orderBy.map((o) => {
                this._validateColumn(o.col) // ВАЛІДАЦІЯ ТУТ
                const dir = o.dir?.toUpperCase() === 'DESC' ? 'DESC' : 'ASC'
                return `${o.col} ${dir}`
            })
            orderSql = `ORDER BY ${orderParts.join(', ')}`
        }

        // Пагінація OFFSET / FETCH
        let paginationSql = ''
        if (pagination) {
            const limit = parseInt(pagination.limit) || 10
            binds.limit = limit

            if (pagination.type === 'offset') {
                binds.offset = (Math.max(1, parseInt(pagination.page || 1)) - 1) * limit
                paginationSql = `OFFSET :offset ROWS FETCH NEXT :limit ROWS ONLY`
            } else {
                paginationSql = `FETCH NEXT :limit ROWS ONLY`
            }
        }

        const finalSql = `SELECT * FROM ${RoleSchema.table} ${whereSql} ${orderSql} ${paginationSql}`

        const result = await db.execute(finalSql, binds)

        return result.rows.map((row) => Role.fromDatabase(row))
    }

    /**
     * Метод підрахунку total records
     */
    async count(filters = { logical: 'AND', criteria: [] }) {
        const db = await this._getExecutor()
        const { sql: whereSql, binds } = this._buildWhereClause(filters)

        const sql = `SELECT COUNT(*) as total FROM ${RoleSchema.table} ${whereSql}`
        const result = await db.execute(sql, binds)

        // В Oracle імена стовпців у результаті часто у верхньому регістрі
        return result.rows[0].TOTAL || result.rows[0].total || 0
    }

    // -------------------------------------

    // /**
    //  * Створює новий запис ролі.
    //  * @param {Role} role - Об'єкт моделі Role.
    //  * @returns {Promise<Role>} Створена роль з отриманим ID.
    //  */
    // async create(role) {
    //     const db = await this._getExecutor()

    //     // Знаходимо конфігурацію первинного ключа (PK)
    //     const pkEntry = Object.entries(RoleSchema.columns).find(([_, col]) => col.isPrimaryKey)
    //     const [pkPropName, pkConfig] = pkEntry

    //     const dbData = role.toDatabaseNames()
    //     const hasProvidedId = role[pkPropName] !== null && role[pkPropName] !== undefined

    //     // Формуємо список колонок для запиту
    //     // Якщо ID не передано, видаляємо його з об'єкта dbData, щоб Oracle спрацював автоматично
    //     if (!hasProvidedId) {
    //         delete dbData[pkConfig.name]
    //     }

    //     const columns = Object.keys(dbData)
    //     const bindNames = columns.map((col) => `:${col}`)

    //     // Використовуємо RETURNING INTO для отримання ID (незалежно від того, хто його створив)
    //     const sql = `
    //         INSERT INTO ${RoleSchema.table} (${columns.join(', ')})
    //         VALUES (${bindNames.join(', ')})
    //         RETURNING ${pkConfig.name} INTO :out_id`

    //     // Налаштовуємо Bind-змінні
    //     const binds = {
    //         ...dbData,
    //         out_id: { type: db.oracledb.NUMBER, dir: db.oracledb.BIND_OUT },
    //     }

    //     const result = await db.execute(sql, binds)

    //     // Отримуємо ID, який або повернула база, або ми самі передали
    //     const finalId = result.outBinds.out_id[0] || role[pkPropName]

    //     // Повертаємо свіжий об'єкт із бази (з усіма дефолтними значеннями та тригерами)
    //     return await this.findById(finalId)
    // }

    /**
     * Створює запис та повертає актуальний об'єкт (з урахуванням тригерів та IDENTITY).
     * @param {Role} role
     * @returns {Promise<Role>}
     */
    async create(role) {
        const db = await this._getExecutor()
        const cols = RoleSchema.columns
        const dbData = role.toDatabaseNames()

        // Видаляємо PK, якщо він порожній, щоб спрацював сиквенс/identity
        const pkConfig = Object.values(cols).find((c) => c.isPrimaryKey)
        if (dbData[pkConfig.name] == null) delete dbData[pkConfig.name]

        // Фільтруємо лише ті колонки, які реально передані (не undefined)
        const providedColumns = Object.keys(dbData).filter((key) => dbData[key] !== undefined)
        const allColumns = Object.values(cols).map((c) => c.name)

        const sql = `
            INSERT INTO ${RoleSchema.table} (${providedColumns.join(', ')})
            VALUES (${providedColumns.map((c) => ':' + c).join(', ')})
            RETURNING ${allColumns.join(', ')}
            INTO ${allColumns.map((c) => ':out_' + c).join(', ')}`

        const binds = {}
        // Вхідні дані
        providedColumns.forEach((col) => {
            binds[col] = dbData[col]
        })
        // Конфігурація для повернення всіх полів схеми
        allColumns.forEach((colName) => {
            binds[`out_${colName}`] = {
                type: this._getOracleType(db, colName),
                dir: db.oracledb.BIND_OUT,
            }
        })

        const result = await db.execute(sql, binds)
        return this._mapOutBindsToModel(result.outBinds, allColumns)
    }

    /**
     * Масове створення (Batch Insert)
     * Найшвидший спосіб вставки через executeMany
     */
    async createMany(roles) {
        if (!roles.length) return []

        const db = await this._getExecutor()

        const dataArray = roles.map((obj) => obj.toDatabaseNames())
        const columns = Object.keys(dataArray[0])
        const bindParams = columns.map((col) => `:${col}`).join(', ')

        const sql = `INSERT INTO ${RoleSchema.table} (${columns.join(', ')}) VALUES (${bindParams})`

        const defs = {}
        const sampleData = dataArray[0]
        for (const key in sampleData) {
            if (typeof sampleData[key] === 'number') {
                defs[key] = { type: db.oracledb.NUMBER }
            } else {
                // Шукаємо максимальну довжину рядка в цій пачці
                const maxLen = dataArray.reduce(
                    (max, row) => Math.max(max, row[key] ? row[key].toString().length : 0),
                    0,
                )

                defs[key] = {
                    type: db.oracledb.STRING,
                    // Додаємо невеликий запас або використовуємо константу зі схеми
                    maxSize: Math.max(maxLen, 100),
                }
            }
        }

        const result = await db.executeMany(sql, dataArray, {
            bindDefs: defs,
        })

        return { count: result.rowsAffected }
    }

    // /**
    //  * Оновлює існуючу роль.
    //  * @param {number|string} id - ID ролі для оновлення.
    //  * @param {Object} roleData - Часткові дані ролі для оновлення.
    //  * @returns {Promise<Role>} Оновлений об'єкт Role.
    //  * @throws {Error} Якщо запис для оновлення не знайдено.
    //  */
    // async update(id, roleData) {
    //     const db = await this._getExecutor()

    //     const pkEntry = Object.entries(RoleSchema.columns).find(([key, col]) => col.isPrimaryKey)
    //     const [pkPropName, pkConfig] = pkEntry

    //     // Створюємо екземпляр моделі, щоб отримати коректні назви колонок
    //     const model = new Role(roleData)
    //     const dbData = model.toDatabaseNames()

    //     // Формуємо рядок SET для SQL, ігноруючи PK в самому SET
    //     const setClauses = Object.keys(dbData)
    //         .filter((colName) => colName !== pkConfig.name)
    //         .map((colName) => `${colName} = :${colName}`)

    //     const sql = `
    //         UPDATE ${RoleSchema.table}
    //         SET ${setClauses.join(', ')}
    //         WHERE ${pkConfig.name} = :target_id`

    //     const binds = {
    //         ...dbData,
    //         target_id: id,
    //     }

    //     const result = await db.execute(sql, binds)

    //     if (result.rowsAffected === 0) {
    //         throw new Error(`Запис з ID ${id} не знайдено для оновлення`)
    //     }

    //     // Повертаємо оновлений об'єкт прямо з бази
    //     return await this.findById(id)
    // }

    /**
     * Оновлює лише передані поля.
     * Повертає актуальний стан рядка після спрацювання всіх тригерів.
     */
    async update(id, roleData) {
        const db = await this._getExecutor()
        const cols = RoleSchema.columns
        const pkConfig = Object.values(cols).find((c) => c.isPrimaryKey)

        const model = new Role(roleData)
        const dbData = model.toDatabaseNames()

        // Визначаємо колонки для SET (не PK і не undefined)
        const updateColumns = Object.keys(dbData).filter(
            (key) => key !== pkConfig.name && dbData[key] !== undefined,
        )

        if (updateColumns.length === 0) {
            return this.findById(id)
        }

        const allColumns = Object.values(cols).map((c) => c.name)

        const sql = `
            UPDATE ${RoleSchema.table}
            SET ${updateColumns.map((c) => `${c} = :${c}`).join(', ')}
            WHERE ${pkConfig.name} = :target_id
            RETURNING ${allColumns.join(', ')}
            INTO ${allColumns.map((c) => ':out_' + c).join(', ')}`

        const binds = { target_id: id }
        updateColumns.forEach((col) => {
            binds[col] = dbData[col]
        })
        allColumns.forEach((colName) => {
            binds[`out_${colName}`] = {
                type: this._getOracleType(db, colName),
                dir: db.oracledb.BIND_OUT,
            }
        })

        const result = await db.execute(sql, binds)

        if (result.rowsAffected === 0) {
            throw new Error(`Запис з ID ${id} не знайдено`)
        }

        return this._mapOutBindsToModel(result.outBinds, allColumns)
    }

    /**
     * Логічне видалення (Soft Delete)
     * Припускаємо, що в схемі може бути колонка deletedAt або isActive
     */
    async softDelete(id) {
        const db = await this._getExecutor()

        const pkConfig = Object.values(RoleSchema.columns).find((c) => c.isPrimaryKey)
        // Використовуємо DELETED_AT (TIMESTAMP) або IS_ACTIVE = 0
        const sql = `UPDATE ${RoleSchema.table} SET DELETED_AT = CURRENT_TIMESTAMP WHERE ${pkConfig.name} = :id`

        const result = await db.execute(sql, { id })
        return result.rowsAffected > 0
    }

    /**
     * Видаляє роль за ID.
     * @param {number|string} id - ID ролі.
     * @returns {Promise<boolean>} True, якщо видалення успішне.
     */
    async delete(id) {
        const db = await this._getExecutor()

        const pkConfig = Object.values(RoleSchema.columns).find((c) => c.isPrimaryKey)

        const sql = `DELETE FROM ${RoleSchema.table} WHERE ${pkConfig.name} = :id`

        const result = await db.execute(sql, { id })

        return result.rowsAffected > 0 // true, якщо видалено хоча б один рядок
    }

    /**
     * Масове видалення ролей за списком ID.
     * @param {Array<number|string>} ids - Масив ID.
     * @returns {Promise<number>} Кількість видалених рядків.
     */
    async deleteMany(ids) {
        if (!ids.length) return []

        const db = await this._getExecutor()

        const pkConfig = Object.values(RoleSchema.columns).find((c) => c.isPrimaryKey)
        // Oracle ефективно працює з IN через масив байндов
        const sql = `DELETE FROM ${RoleSchema.table} WHERE ${pkConfig.name} IN (SELECT column_value FROM TABLE(:id_list))`

        const result = await db.execute(sql, {
            id_list: { type: db.oracledb.NUMBER, val: ids, dir: db.oracledb.BIND_IN },
        })

        return result.rowsAffected
    }
}
