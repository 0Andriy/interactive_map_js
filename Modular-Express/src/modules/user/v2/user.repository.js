// user.repository.js
import oracledb from 'oracledb'
import UserSchema from './user.schema.js'
import RoleSchema from '../role/role.schema.js'
import User from './user.model.js'

class UserRepository {
    constructor(db) {
        this.db = db
    }

    async initializeSchema() {
        const userTable = UserSchema.table.toUpperCase()
        const pivotTable = UserSchema.pivotTable.toUpperCase()

        // 1. Створення основної таблиці USERS
        const checkUser = await this.db.execute(
            `SELECT table_name FROM user_tables WHERE table_name = :userTable`,
            { userTable },
        )

        if (checkUser.rows.length === 0) {
            await this.db.execute(`
      CREATE TABLE ${userTable} (
        ${UserSchema.columns.id.name} NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        ${UserSchema.columns.username.name} VARCHAR2(50) NOT NULL UNIQUE,
        ${UserSchema.columns.email.name} VARCHAR2(100) NOT NULL,
        ${UserSchema.columns.password.name} VARCHAR2(255) NOT NULL,
        ${UserSchema.columns.isActive.name} NUMBER(1) DEFAULT 1
      )
    `)
        }

        // 2. Створення таблиці зв'язків USER_ROLES_LINK
        const checkPivot = await this.db.execute(
            `SELECT table_name FROM user_tables WHERE table_name = :pivotTable`,
            { pivotTable },
        )

        if (checkPivot.rows.length === 0) {
            const { userId, roleId } = UserSchema.pivotColumns
            await this.db.execute(`
      CREATE TABLE ${pivotTable} (
        ${userId} NUMBER NOT NULL,
        ${roleId} NUMBER NOT NULL,
        CONSTRAINT pk_user_role PRIMARY KEY (${userId}, ${roleId}),
        CONSTRAINT fk_user FOREIGN KEY (${userId}) REFERENCES ${userTable}(${UserSchema.columns.id.name}) ON DELETE CASCADE,
        CONSTRAINT fk_role FOREIGN KEY (${roleId}) REFERENCES ${RoleSchema.table}(${RoleSchema.columns.id.name}) ON DELETE CASCADE
      )
    `)
        }

        const userCount = await this.db.execute(`SELECT COUNT(*) as cnt FROM ${UserSchema.table}`)
        if (userCount.rows[0].CNT === 0) {
            console.log(`[Database] Seeding initial admin user...`)

            // admin123 захешований через bcrypt
            const hashedPass = '$2b$10$YourHashedPasswordHere...'

            // 1. Створюємо юзера
            const adminId = 1
            await this.db.execute(
                `INSERT INTO ${UserSchema.table}
      (${UserSchema.columns.id.name}, ${UserSchema.columns.username.name},
       ${UserSchema.columns.email.name}, ${UserSchema.columns.password.name})
      VALUES (:id, :username, :email, :pass)`,
                { id: adminId, username: 'admin', email: 'admin@system.com', pass: hashedPass },
            )

            // 2. Прив'язуємо роль ADMIN (ID=1)
            await this.db.execute(
                `INSERT INTO ${UserSchema.pivotTable}
      (${UserSchema.pivotColumns.userId}, ${UserSchema.pivotColumns.roleId})
      VALUES (:uId, :rId)`,
                { uId: adminId, rId: 1 },
                { autoCommit: true },
            )
        }
    }

    /**
     * Отримати користувача за ID разом з його ролями
     */
    async findById(id) {
        const pk = UserSchema.columns.id.name
        const pivot = UserSchema.pivotTable
        const roleTable = RoleSchema.table

        // SQL запит з JOIN для отримання юзера та його ролей
        const query = `
      SELECT u.*, r.*
      FROM ${UserSchema.table} u
      LEFT JOIN ${pivot} lnk ON u.${pk} = lnk.${UserSchema.pivotColumns.userId}
      LEFT JOIN ${roleTable} r ON lnk.${UserSchema.pivotColumns.roleId} = r.${RoleSchema.columns.id.name}
      WHERE u.${pk} = :id
    `

        const result = await this.db.execute(
            query,
            { id },
            { outFormat: oracledb.OUT_FORMAT_OBJECT },
        )

        if (result.rows.length === 0) return null

        // Оскільки JOIN повертає кілька рядків для одного юзера (через різні ролі),
        // ми беремо дані юзера з першого рядка, а ролі збираємо з усіх.
        const userRow = result.rows[0]
        const rolesRows = result.rows.filter((row) => row[RoleSchema.columns.id.name] !== null)

        return User.fromDatabase(userRow, rolesRows)
    }

    async findByUsername(username) {
        const loginCol = UserSchema.columns.username.name
        const pk = UserSchema.columns.id.name
        const pivot = UserSchema.pivotTable
        const roleTable = RoleSchema.table

        const query = `
    SELECT u.*, r.*
    FROM ${UserSchema.table} u
    LEFT JOIN ${pivot} lnk ON u.${pk} = lnk.${UserSchema.pivotColumns.userId}
    LEFT JOIN ${roleTable} r ON lnk.${UserSchema.pivotColumns.roleId} = r.${RoleSchema.columns.id.name}
    WHERE u.${loginCol} = :username
  `

        const result = await this.db.execute(
            query,
            { username },
            { outFormat: oracledb.OUT_FORMAT_OBJECT },
        )

        if (result.rows.length === 0) return null

        // Оскільки ми використовуємо JOIN, збираємо юзера та масив його ролей
        const rolesRows = result.rows.filter((row) => row[RoleSchema.columns.id.name])

        // Створюємо модель (пароль буде доступний в об'єкті, але зникне при toJSON())
        return User.fromDatabase(result.rows[0], rolesRows)
    }

    /**
     * Створити користувача та прив'язати ролі
     */
    async create(user, roleIds = []) {
        const dbData = user.toDatabaseNames()
        const cols = Object.keys(dbData).join(', ')
        const binds = Object.keys(dbData)
            .map((k) => `:${k}`)
            .join(', ')

        // 1. Вставка в основну таблицю
        const insertUserSql = `INSERT INTO ${UserSchema.table} (${cols}) VALUES (${binds})`
        await this.db.execute(insertUserSql, dbData)

        // 2. Вставка зв'язків з ролями (Batch insert імітація)
        if (roleIds.length > 0) {
            const pivot = UserSchema.pivotTable
            const { userId, roleId } = UserSchema.pivotColumns

            for (const rId of roleIds) {
                await this.db.execute(
                    `INSERT INTO ${pivot} (${userId}, ${roleId}) VALUES (:uId, :rId)`,
                    { uId: user.id, rId },
                )
            }
        }

        await this.db.execute('COMMIT') // Фіксуємо транзакцію
        return user
    }

    async update(id, userData) {
        const pk = UserSchema.columns.id.name

        // Створюємо модель для мапінгу на назви колонок Oracle
        const userModel = new User(userData)
        const dbData = userModel.toDatabaseNames()

        // Видаляємо PK з даних для оновлення, щоб не змінити його випадково
        delete dbData[pk]

        if (Object.keys(dbData).length === 0) return false

        // Динамічно формуємо рядок SET: COL1 = :COL1, COL2 = :COL2
        const setClause = Object.keys(dbData)
            .map((col) => `${col} = :${col}`)
            .join(', ')

        const query = `UPDATE ${UserSchema.table} SET ${setClause} WHERE ${pk} = :id`

        const result = await this.db.execute(query, { ...dbData, id }, { autoCommit: true })
        return result.rowsAffected > 0
    }

    async syncRoles(userId, roleIds) {
        const { userId: uCol, roleId: rCol } = UserSchema.pivotColumns
        await this.db.execute(
            `DELETE FROM ${UserSchema.pivotTable} WHERE ${uCol} = :userId`,
            { userId },
            { autoCommit: false },
        )

        if (roleIds.length > 0) {
            const bindData = roleIds.map((rId) => ({ userId, rId }))
            await this.db.executeMany(
                `INSERT INTO ${UserSchema.pivotTable} (${uCol}, ${rCol}) VALUES (:userId, :rId)`,
                bindData,
                { autoCommit: false },
            )
        }
        await this.db.execute('COMMIT')
    }

    /**
     * Видалити користувача та його зв'язки
     */
    async delete(id) {
        const pk = UserSchema.columns.id.name
        const pivot = UserSchema.pivotTable
        const uIdCol = UserSchema.pivotColumns.userId

        // Спочатку видаляємо зв'язки (Constraint safety)
        await this.db.execute(`DELETE FROM ${pivot} WHERE ${uIdCol} = :id`, { id })

        // Потім видаляємо юзера
        const result = await this.db.execute(`DELETE FROM ${UserSchema.table} WHERE ${pk} = :id`, {
            id,
        })

        await this.db.execute('COMMIT')
        return result.rowsAffected > 0
    }
}

export default UserRepository
