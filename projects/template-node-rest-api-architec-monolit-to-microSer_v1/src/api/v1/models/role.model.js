// src/models/role.model.js
import oracleDbManager from '../../../db/OracleDbManager.js'
import logger from '../../../utils/logger.js'

class RoleModel {
    /**
     * Створення таблиці з усім необхідним.
     */
    async createTable(dbName) {
        const createTableSQL = {
            // Таблиці
            roles: `
                CREATE TABLE ROLES (
                    ROLE_ID                 NUMBER(10)      GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                    ROLE_NAME               VARCHAR2(50)    NOT NULL UNIQUE,
                    DESCRIPTION             VARCHAR2(255),
                    CREATED_AT              TIMESTAMP       DEFAULT SYSTIMESTAMP NOT NULL,
                    UPDATED_AT              TIMESTAMP       DEFAULT SYSTIMESTAMP NOT NULL
                )
            `,

            // Індекси

            // Коментарі до таблиць
            comment_roles: `COMMENT ON TABLE ROLES IS 'Таблиця для визначення доступних ролей в системі.'`,
            comment_col_roles_role_id: `COMMENT ON COLUMN ROLES.ROLE_ID IS 'Унікальний ідентифікатор ролі.'`,
            comment_col_roles_role_name: `COMMENT ON COLUMN ROLES.ROLE_NAME IS 'Назва ролі (наприклад, admin, editor).'`,
            comment_col_roles_description: `COMMENT ON COLUMN ROLES.DESCRIPTION IS 'Опис ролі.'`,
            comment_col_roles_created_at: `COMMENT ON COLUMN ROLES.CREATED_AT IS 'Дата і час створення ролі.'`,
            comment_col_roles_updated_at: `COMMENT ON COLUMN ROLES.UPDATED_AT IS 'Дата і час останнього оновлення ролі.'`,
        }

        const tableOrder = ['roles']

        const indexOrder = []

        const commentOrder = [
            'comment_roles',
            'comment_col_roles_role_id',
            'comment_col_roles_role_name',
            'comment_col_roles_description',
            'comment_col_roles_created_at',
            'comment_col_roles_updated_at',
        ]

        for (const tableName of tableOrder) {
            try {
                await oracleDbManager.execute(dbName, createTableSQL[tableName])
                logger.info(`Table '${tableName.toUpperCase()}' created successfully.`)
            } catch (error) {
                if (error.oracleErrorNum === 955) {
                    // ORA-00955: name is already used by an existing object
                    logger.warn(
                        `Table '${tableName.toUpperCase()}' already exists. Skipping creation.`,
                    )
                } else {
                    logger.error(
                        `Error creating table '${tableName.toUpperCase()}': ${error.message}`,
                        { error },
                    )
                    throw error // Зупиняємо, якщо є критична помилка
                }
            }
        }

        for (const indexName of indexOrder) {
            try {
                await oracleDbManager.execute(dbName, createTableSQL[indexName])
                logger.info(`Index '${indexName.toUpperCase()}' created successfully.`)
            } catch (error) {
                if (error.oracleErrorNum === 955) {
                    logger.warn(
                        `Index '${indexName.toUpperCase()}' already exists. Skipping creation.`,
                    )
                } else {
                    logger.error(
                        `Error creating index '${indexName.toUpperCase()}': ${error.message}`,
                        { error },
                    )
                    throw error
                }
            }
        }

        for (const commentName of commentOrder) {
            try {
                await oracleDbManager.execute(dbName, createTableSQL[commentName])
                logger.info(`Comment for '${commentName}' added successfully.`)
            } catch (error) {
                logger.error(`Error adding comment for '${commentName}': ${error.message}`, {
                    error,
                })
                // Не зупиняємо процес через помилку коментаря, це не критично для функціоналу
            }
        }
    }

    /**
     * Створює нову роль.
     * @param {string} dbName - Назва бази даних
     * @param {string} roleName - Назва ролі.
     * @param {string} [description=null] - Опис ролі.
     * @returns {Promise<object>} Об'єкт створеної ролі.
     * @throws {Error} Якщо виникає помилка при створенні (наприклад, дублікат roleName).
     */
    async create(dbName, roleName, description = null) {
        try {
            const sql = `
                INSERT INTO ROLES (ROLE_NAME, DESCRIPTION)
                VALUES (:roleName, :description)
                RETURNING ROLE_ID, ROLE_NAME, DESCRIPTION, CREATED_AT, UPDATED_AT INTO
                    :out_roleId, :out_roleName, :out_description, :out_createdAt, :out_updatedAt
            `

            const binds = {
                roleName,
                description: description || null,
                out_roleId: {
                    type: oracleDbManager.oracledb.NUMBER,
                    dir: oracleDbManager.oracledb.BIND_OUT,
                },
                out_roleName: {
                    type: oracleDbManager.oracledb.STRING,
                    dir: oracleDbManager.oracledb.BIND_OUT,
                },
                out_description: {
                    type: oracleDbManager.oracledb.STRING,
                    dir: oracleDbManager.oracledb.BIND_OUT,
                },
                out_createdAt: {
                    type: oracleDbManager.oracledb.DATE,
                    dir: oracleDbManager.oracledb.BIND_OUT,
                },
                out_updatedAt: {
                    type: oracleDbManager.oracledb.DATE,
                    dir: oracleDbManager.oracledb.BIND_OUT,
                },
            }

            const options = { autoCommit: true }

            const result = await oracleDbManager.execute(dbName, sql, binds, options)
            const outBinds = result.outBinds

            return {
                roleId: outBinds.out_roleId[0],
                roleName: outBinds.out_roleName[0],
                description: outBinds.out_description[0],
                createdAt: outBinds.out_createdAt[0],
                updatedAt: outBinds.out_updatedAt[0],
            }
        } catch (error) {
            logger.error(`Error creating role '${roleName}': ${error.message}`, { error })
            if (error.oracleErrorNum === 1 && error.message.includes('ROLES_ROLE_NAME_UK')) {
                throw new Error('Role name already exists.')
            }
            throw error
        }
    }

    /**
     * Отримує роль за ID.
     * @param {string} dbName - Назва бази даних
     * @param {number} roleId - ID ролі.
     * @returns {Promise<object|null>} Об'єкт ролі або null.
     * @throws {Error} Якщо виникає помилка при пошуку.
     */
    async findById(dbName, roleId) {
        try {
            const sql = `
                SELECT ROLE_ID, ROLE_NAME, DESCRIPTION, CREATED_AT, UPDATED_AT
                FROM ROLES
                WHERE ROLE_ID = :roleId
            `

            const binds = { roleId }

            const result = await oracleDbManager.execute(dbName, sql, binds)

            return result.rows.length > 0 ? result.rows[0] : null
        } catch (error) {
            logger.error(`Error finding role by ID ${roleId}: ${error.message}`, { error })
            throw error
        }
    }

    /**
     * Отримує роль за назвою.
     * @param {string} dbName - Назва бази даних
     * @param {string} roleName - Назва ролі.
     * @returns {Promise<object|null>} Об'єкт ролі або null.
     * @throws {Error} Якщо виникає помилка при пошуку.
     */
    async findByName(dbName, roleName) {
        try {
            const sql = `
                SELECT ROLE_ID, ROLE_NAME, DESCRIPTION, CREATED_AT, UPDATED_AT
                FROM ROLES
                WHERE ROLE_NAME = :roleName
            `

            const binds = { roleName }

            const result = await oracleDbManager.execute(dbName, sql, binds)

            return result.rows.length > 0 ? result.rows[0] : null
        } catch (error) {
            logger.error(`Error finding role by name '${roleName}': ${error.message}`, {
                error,
            })
            throw error
        }
    }

    /**
     * Отримує всі ролі.
     * @param {string} dbName - Назва бази даних
     * @returns {Promise<Array<object>>} Масив об'єктів ролей.
     * @throws {Error} Якщо виникає помилка при отриманні списку.
     */
    async getAll(dbName) {
        try {
            const sql = `
                SELECT ROLE_ID, ROLE_NAME, DESCRIPTION, CREATED_AT, UPDATED_AT
                FROM ROLES
                ORDER BY ROLE_NAME
            `

            const result = await oracleDbManager.execute(dbName, sql)

            return result.rows
        } catch (error) {
            logger.error(`Error getting all roles: ${error.message}`, { error })
            throw error
        }
    }

    /**
     * Оновлює роль.
     * @param {string} dbName - Назва бази даних
     * @param {number} roleId - ID ролі.
     * @param {object} updates - Об'єкт з полями для оновлення.
     * @returns {Promise<boolean>} True, якщо оновлено, false, якщо ні.
     * @throws {Error} Якщо виникає помилка при оновленні.
     */
    async update(dbName, roleId, updates) {
        try {
            const setClauses = []
            const binds = { roleId }

            setClauses.push('UPDATED_AT = SYSTIMESTAMP')

            for (const key in updates) {
                if (
                    updates.hasOwnProperty(key) &&
                    ['ROLE_NAME', 'DESCRIPTION'].includes(key.toUpperCase())
                ) {
                    setClauses.push(`${key.toUpperCase()} = :${key}`)
                    binds[key] = updates[key]
                }
            }

            if (setClauses.length === 0) {
                logger.warn(`No updatable fields provided for role ${roleId}`)
                return false
            }

            const sql = `
                UPDATE ROLES
                SET ${setClauses.join(', ')}
                WHERE ROLE_ID = :roleId
            `

            const result = await oracleDbManager.execute(dbName, sql, binds, { autoCommit: true })

            if (result.rowsAffected === 1) {
                logger.info(`Role ${roleId} updated successfully.`)
            } else {
                logger.warn(`Role ${roleId} not updated (not found or no changes).`)
            }

            return result.rowsAffected === 1
        } catch (error) {
            logger.error(`Error updating role ${roleId}: ${error.message}`, {
                error,
                updates,
            })
            if (error.oracleErrorNum === 1 && error.message.includes('ROLES_ROLE_NAME_UK')) {
                throw new Error('Role name already exists.')
            }
            throw error
        }
    }

    /**
     * Видаляє роль (фізично).
     * @param {string} dbName - Назва бази даних
     * @param {number} roleId - ID ролі.
     * @returns {Promise<boolean>} True, якщо видалено, false, якщо ні.
     * @throws {Error} Якщо виникає помилка при видаленні.
     */
    async delete(dbName, roleId) {
        try {
            const sql = `
                DELETE FROM ROLES
                WHERE ROLE_ID = :roleId
            `

            const binds = { roleId }

            const result = await oracleDbManager.execute(dbName, sql, binds, { autoCommit: true })

            if (result.rowsAffected === 1) {
                logger.info(`Role ${roleId} deleted successfully.`)
            } else {
                logger.warn(`Role ${roleId} not deleted (not found).`)
            }

            return result.rowsAffected === 1
        } catch (error) {
            logger.error(`Error deleting role ${roleId}: ${error.message}`, { error })
            // ORA-02292: integrity constraint (SCHEMA.FK_USER_ROLES_ROLE) violated - child record found
            if (error.oracleErrorNum === 2292) {
                throw new Error('Cannot delete role: it is assigned to one or more users.')
            }
            throw error
        }
    }
}

export default new RoleModel()
