// src/models/RefreshToken.js
import oracleDbManager from '../db/OracleDbManager.js'
import logger from '../utils/logger.js'

export const RefreshToken = {
    async createTable() {
        try {
            const createTableSql = `
                CREATE TABLE refresh_tokens (
                    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                    user_id NUMBER NOT NULL, -- Змінено на NUMBER відповідно до ID користувача
                    token VARCHAR2(500) UNIQUE NOT NULL,
                    expires_at TIMESTAMP WITH LOCAL TIME ZONE NOT NULL,
                    created_at TIMESTAMP WITH LOCAL TIME ZONE DEFAULT SYSTIMESTAMP,
                    CONSTRAINT fk_refresh_token_user FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `
            await oracleDbManager.execute(createTableSql, {}, { autoCommit: true })
            logger.info('Table "refresh_tokens" created successfully or already exists.')
        } catch (err) {
            if (err.errorNum === 955) {
                logger.warn('Table "refresh_tokens" already exists, skipping creation.')
            } else {
                logger.error('Error creating refresh_tokens table:', err.message)
                throw err
            }
        }
    },

    async create(userId, token, expiresInMs) {
        try {
            const expiresAt = new Date(Date.now() + expiresInMs)

            const insertSql = `
                INSERT INTO refresh_tokens (user_id, token, expires_at)
                VALUES (:userId, :token, :expiresAt)
                RETURNING id INTO :id_out
            `
            const bindVars = {
                userId: userId, // userId тепер NUMBER
                token: token,
                expiresAt: expiresAt,
                id_out: {
                    type: oracleDbManager.oracledb.NUMBER,
                    dir: oracleDbManager.oracledb.BIND_OUT,
                }, // Очікуємо числове ID
            }

            const result = await oracleDbManager.execute(insertSql, bindVars, { autoCommit: true })
            const newId = result.outBinds.id_out[0]
            return { id: newId, userId, token, expiresAt }
        } catch (err) {
            logger.error('Error creating refresh token:', err.message)
            throw err
        }
    },

    async findByToken(token) {
        try {
            const result = await oracleDbManager.execute(
                `SELECT id, user_id, token, expires_at FROM refresh_tokens WHERE token = :token`,
                { token },
            )
            if (result.rows.length === 0) return null
            const refreshToken = result.rows[0]
            // ID та USER_ID тепер NUMBER, toString('hex') не потрібен
            return refreshToken
        } catch (err) {
            logger.error('Error finding refresh token by token:', err.message)
            throw err
        }
    },

    async deleteById(id) {
        try {
            const result = await oracleDbManager.execute(
                `DELETE FROM refresh_tokens WHERE id = :id`,
                { id: id }, // ID тепер NUMBER
                { autoCommit: true },
            )
            return result.rowsAffected > 0
        } catch (err) {
            logger.error('Error deleting refresh token by ID:', err.message)
            throw err
        }
    },

    async deleteByToken(token) {
        try {
            const result = await oracleDbManager.execute(
                `DELETE FROM refresh_tokens WHERE token = :token`,
                { token },
                { autoCommit: true },
            )
            return result.rowsAffected > 0
        } catch (err) {
            logger.error('Error deleting refresh token by token:', err.message)
            throw err
        }
    },

    async deleteByUserId(userId) {
        try {
            const result = await oracleDbManager.execute(
                `DELETE FROM refresh_tokens WHERE user_id = :userId`,
                { userId: userId }, // userId тепер NUMBER
                { autoCommit: true },
            )
            return result.rowsAffected > 0
        } catch (err) {
            logger.error('Error deleting refresh tokens by user ID:', err.message)
            throw err
        }
    },

    async cleanExpiredTokens() {
        try {
            const result = await oracleDbManager.execute(
                `DELETE FROM refresh_tokens WHERE expires_at < SYSTIMESTAMP`,
                {},
                { autoCommit: true },
            )
            logger.info(`Cleaned up ${result.rowsAffected} expired refresh tokens.`)
            return result.rowsAffected
        } catch (err) {
            logger.error('Error cleaning expired refresh tokens:', err.message)
            throw err
        }
    },
}
