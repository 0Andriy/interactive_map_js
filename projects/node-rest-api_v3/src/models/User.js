// src/models/User.js
import oracleDbManager from '../db/OracleDbManager.js'
import logger from '../utils/logger.js'

export const User = {
    async createTable() {
        try {
            // Використовуємо NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY для авто-інкрементного числового ID
            const createTableSql = `
                CREATE TABLE users (
                    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                    username VARCHAR2(30) UNIQUE NOT NULL,
                    email VARCHAR2(100) UNIQUE NOT NULL,
                    password VARCHAR2(255) NOT NULL,
                    roles VARCHAR2(4000) DEFAULT '["user"]' NOT NULL,
                    created_at TIMESTAMP WITH LOCAL TIME ZONE DEFAULT SYSTIMESTAMP
                )
            `
            await oracleDbManager.execute(createTableSql, {}, { autoCommit: true })
            logger.info('Table "users" created successfully or already exists.')

            await oracleDbManager.execute(
                `CREATE UNIQUE INDEX idx_users_email ON users (email)`,
                {},
                { autoCommit: true },
            )
            await oracleDbManager.execute(
                `CREATE UNIQUE INDEX idx_users_username ON users (username)`,
                {},
                { autoCommit: true },
            )
        } catch (err) {
            if (err.errorNum === 955) {
                // ORA-00955: name is already used by an existing object
                logger.warn('Table "users" already exists, skipping creation.')
            } else {
                logger.error('Error creating users table:', err.message)
                throw err
            }
        }
    },

    async findByEmail(email) {
        try {
            const result = await oracleDbManager.execute(
                `SELECT id, username, email, password, roles FROM users WHERE email = :email`,
                { email },
            )
            if (result.rows.length === 0) return null
            const user = result.rows[0]
            user.ROLES = JSON.parse(user.ROLES) // Якщо ролі зберігаються як JSON-рядок
            return user
        } catch (err) {
            logger.error(`Error finding user by email (${email}):`, err.message)
            throw err
        }
    },

    async findByUsername(username) {
        try {
            const result = await oracleDbManager.execute(
                `SELECT id, username, email, password, roles FROM users WHERE username = :username`,
                { username },
            )
            if (result.rows.length === 0) return null
            const user = result.rows[0]
            // ID тепер NUMBER
            user.ROLES = JSON.parse(user.ROLES)
            return user
        } catch (err) {
            logger.error(`Error finding user by username (${username}):`, err.message)
            throw err
        }
    },

    async createUser(userData) {
        try {
            const hashedPassword = await hashPassword(userData.password)
            const rolesString = JSON.stringify(userData.roles || ['user'])

            // ID генерується автоматично, тому не включаємо його в INSERT VALUES
            const insertSql = `
                INSERT INTO users (username, email, password, roles)
                VALUES (:username, :email, :hashedPassword, :rolesString)
                RETURNING id INTO :id_out
            `
            const bindVars = {
                username: userData.username,
                email: userData.email,
                hashedPassword: hashedPassword,
                rolesString: rolesString,
                id_out: {
                    type: oracleDbManager.oracledb.NUMBER,
                    dir: oracleDbManager.oracledb.BIND_OUT,
                }, // Очікуємо числове ID
            }

            const result = await oracleDbManager.execute(insertSql, bindVars, { autoCommit: true })
            const newId = result.outBinds.id_out[0] // ID тепер буде числом

            return {
                id: newId,
                username: userData.username,
                email: userData.email,
                roles: JSON.parse(rolesString),
            }
        } catch (err) {
            logger.error('Error creating user:', err.message)
            throw err
        }
    },
}
