# Використовуємо офіційний образ Node.js як базовий.
# 'lts-alpine' рекомендується для виробничих середовищ:
# - 'lts' означає Long Term Support, що забезпечує стабільність.
# - 'alpine' - це легкий дистрибутив Linux, що робить образ меншим і безпечнішим.
FROM node:lts-alpine

# Задаємо робочу директорію всередині контейнера.
# Всі подальші команди (COPY, RUN, CMD) будуть виконуватися відносно цієї директорії.
WORKDIR /app

# --- Встановлення системних залежностей для Oracle Instant Client ---
# Alpine використовує 'apk', а не 'apt-get'.
# 'libaio' потрібна для Oracle. 'unzip' для розпакування Instant Client, якщо ви копіюєте zip-архів.
# Використовуйте --no-cache для зменшення розміру образу.
RUN apk add --no-cache libaio unzip

# [Опціонально] Встановлення додаткових системних залежностей, якщо потрібні нативні компіляції.
# Якщо ваші Node.js пакети мають нативні компіляції, можуть знадобитися 'python3', 'make', 'g++'.
# Зауважте: Це значно збільшить розмір образу.
# RUN apk add --no-cache python3 make g++ libstdc++

# --- Копіюємо та налаштовуємо Oracle Instant Client ---
# Важливо:
# 1. Завжди використовуйте 'bin/oracle' як джерело на хості.
# 2. У папці 'bin/oracle' повинні бути всі необхідні файли:
#    - libclntsh.so (або libclntsh.so.XX.X)
#    - libocci.so (або libocci.so.XX.X)
#    - ojdbcX.jar (якщо потрібно для JDBC)
# 3. Розпаковувати Instant Client краще на хості перед копіюванням, а копіювати вже розпаковані файли.
#    Якщо ви копіюєте zip-архів, вам потрібно буде його розпакувати в цьому ж шарі.
COPY bin/oracle /opt/oracle/instantclient/

# --- Встановлюємо змінні середовища для Oracle Instant Client ---
# LD_LIBRARY_PATH вказує системі, де шукати динамічні бібліотеки Oracle.
# PATH може бути корисним, якщо ви будете використовувати утиліти командного рядка Oracle.
ENV LD_LIBRARY_PATH="/opt/oracle/instantclient:${LD_LIBRARY_PATH}"
ENV PATH="/opt/oracle/instantclient:${PATH}"

# --- Копіюємо сертифікати (SSL/TLS) ---
# Переконайтесь, що папка 'cert' у корені вашого проєкту містить потрібні сертифікати.
COPY cert /app/cert

# Копіюємо package.json та package-lock.json (або yarn.lock) до робочої директорії.
# Цей крок виконується окремо для використання переваг кешування шарів Docker.
# Якщо файли залежностей не змінюються, Docker не буде повторно виконувати 'npm install'.
COPY package*.json ./

# Встановлюємо залежності проєкту.
# Використовуємо 'npm ci' для чистої установки на основі package-lock.json,
# що гарантує ідентичні збірки. Для yarn використовуйте 'yarn install --frozen-lockfile'.
# Використання --production гарантує, що встановлюються тільки виробничі залежності.
RUN npm ci --production

# Копіюємо решту коду застосунку до робочої директорії.
# Використовуємо .dockerignore для виключення файлів, які не потрібні в образі (наприклад, node_modules, .git).
COPY . .

# --- Налаштування директорії для логів ---
# Створення окремої директорії для логів, яка буде монтуватися як том.
# Це дозволяє зберігати логи поза контейнером і забезпечувати доступ до них.
# Переконайтеся, що користувач контейнера має права на запис у цю директорію.
# Встановлюємо власника 'node:node', оскільки сервіс буде запускатися від імені користувача 'node'.
RUN mkdir -p /app/logs && chown node:node /app/logs

# Вказуємо порт, на якому застосунок слухатиме в контейнері.
# Це лише документація, яка не публікує порт автоматично, але допомагає Docker-інструментам.
EXPOSE 3000

# Перемикаємося на не-root користувача (user 'node' в образі 'alpine').
# Це важливий крок для безпеки: зменшує ризики, якщо застосунок буде скомпрометований.
# Завжди перемикайтеся на не-root користувача перед CMD.
USER node

# Визначаємо команду, яка буде виконуватися при старті контейнера.
# 'npm start' повинен бути визначений у вашому package.json в секції 'scripts'.
CMD ["npm", "start"]
