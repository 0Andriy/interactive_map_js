// sql/oracleGenerators.js

import { createOperation } from './operationBuilder.js' //'../utils/operationBuilder.js'

/**
 * Екранує одинарні лапки для використання у SQL-рядках.
 * @param {string} str - Вхідний рядок.
 * @returns {string} Екранований рядок.
 */
const escapeStringForSQL = (str) => str.replace(/'/g, "''")

/**
 * Генерує SQL-визначення для одного стовпця таблиці.
 * @param {object} column - Об'єкт, що описує стовпець.
 * @returns {string} SQL-фрагмент для стовпця.
 */
const generateColumnDefinition = (column) => {
    // let colDef = `${column.name} ${column.type}`

    // Встановіть ці значення відповідно до очікуваної максимальної довжини
    // назв ваших колонок і типів.
    // Якщо якесь ім'я або тип буде довшим, воно не вирівняється і "зсуне" наступну колонку.
    const columnNameFixedLength = 15 // Достатньо для "EXPIRATION_DATE" (15 символів)
    const columnTypeFixedLength = 20 // Достатньо для "VARCHAR2(255)" (14 символів)

    let colDef = ''

    // Вирівнюємо ім'я колонки
    colDef += column.name.padEnd(columnNameFixedLength)

    // Додаємо тип колонки (можливо, з додатковим пробілом для розділення)
    colDef += ` ${column.type.padEnd(columnTypeFixedLength)}` // Додатковий пробіл

    let modifiers = ''
    if (column.primaryKey) modifiers += ' PRIMARY KEY'
    if (column.identity) modifiers += ' GENERATED BY DEFAULT ON NULL AS IDENTITY'
    if (column.notNull) modifiers += ' NOT NULL'
    // UNIQUE на рівні стовпця, якщо це не первинний ключ (бо PK вже має UNIQUE)
    if (column.unique && !column.primaryKey) modifiers += ' UNIQUE'
    if (column.default !== undefined) {
        // Якщо значення за замовчуванням є рядком і це не SYSTIMESTAMP, то додаємо лапки
        modifiers += ` DEFAULT ${
            typeof column.default === 'string' && column.default !== 'SYSTIMESTAMP'
                ? `'${escapeStringForSQL(column.default)}'`
                : column.default
        }`
    }
    // Тепер вирівнюємо 'baseDef' і додаємо 'modifiers'
    // Використовуємо .padEnd() для 'baseDef'
    // Якщо модифікаторів немає, modifiers залишиться порожнім рядком, і зайвих пробілів не буде.
    return `${modifiers.length > 0} ? ${colDef}${modifiers} : ${colDef.trim()}`
}

/**
 * Генерує SQL-визначення для одного обмеження таблиці (FOREIGN KEY, UNIQUE, CHECK).
 * @param {object} constraint - Об'єкт, що описує обмеження.
 * @returns {string} SQL-фрагмент для обмеження.
 */
const generateConstraintDefinition = (constraint) => {
    let constraintDef = `CONSTRAINT ${constraint.name} ${constraint.type}`
    if (constraint.type === 'FOREIGN KEY') {
        constraintDef += ` (${constraint.columns.join(', ')}) REFERENCES ${constraint.references}`
        if (constraint.onDelete) {
            constraintDef += ` ON DELETE ${constraint.onDelete.toUpperCase()}`
        }
    } else if (constraint.type === 'UNIQUE') {
        constraintDef += ` (${constraint.columns.join(', ')})`
    } else if (constraint.type === 'CHECK') {
        constraintDef += ` (${constraint.expression})`
    }
    return constraintDef
}

/**
 * Генерує повний SQL-запит CREATE TABLE.
 * @param {object} tableDef - Об'єкт, що описує таблицю.
 * @returns {string} Повний SQL-запит CREATE TABLE.
 */
const generateCreateTableSQL = (tableDef) => {
    const columnsSQL = tableDef.columns.map(generateColumnDefinition).join(',\n        ')

    const constraintsSQL = (tableDef.constraints || [])
        .map(generateConstraintDefinition)
        .join(',\n        ')

    let tableBody = columnsSQL
    if (constraintsSQL) {
        tableBody += `,\n        ${constraintsSQL}`
    }

    return `
CREATE TABLE ${tableDef.name} (
        ${tableBody}
    )`
}

/**
 * Генерує SQL-запит CREATE INDEX.
 * @param {string} tableName - Назва таблиці, до якої належить індекс.
 * @param {object} indexDef - Об'єкт, що описує індекс.
 * @returns {string} Повний SQL-запит CREATE INDEX.
 */
const generateCreateIndexSQL = (tableName, indexDef) => {
    return `CREATE ${indexDef.unique ? 'UNIQUE ' : ''}INDEX ${
        indexDef.name
    } ON ${tableName} (${indexDef.columns.join(', ')})`
}

/**
 * Генерує SQL-запит COMMENT ON TABLE.
 * @param {string} tableName - Назва таблиці.
 * @param {string} comment - Коментар до таблиці.
 * @returns {string} Повний SQL-запит COMMENT ON TABLE.
 */
const generateTableCommentSQL = (tableName, comment) => {
    return `COMMENT ON TABLE ${tableName} IS '${escapeStringForSQL(comment)}'`
}

/**
 * Генерує SQL-запит COMMENT ON COLUMN.
 * @param {string} tableName - Назва таблиці.
 * @param {string} columnName - Назва стовпця.
 * @param {string} comment - Коментар до стовпця.
 * @returns {string} Повний SQL-запит COMMENT ON COLUMN.
 */
const generateColumnCommentSQL = (tableName, columnName, comment) => {
    return `COMMENT ON COLUMN ${tableName}.${columnName} IS '${escapeStringForSQL(comment)}'`
}

/**
 * Збирає всі операції схеми з декларативного визначення.
 * @param {object} schemaDefinition - Об'єкт з декларативним описом схеми.
 * @returns {Array<object>} Масив об'єктів операцій, готових до виконання.
 */
export const buildSchemaOperations = (schemaDefinition) => {
    const operations = []

    // Обробка таблиць
    for (const tableDef of schemaDefinition.tables) {
        const tableName = tableDef.name

        // 1. Операція: Створення таблиці
        operations.push(
            createOperation(
                tableName,
                generateCreateTableSQL(tableDef),
                'TABLE_CREATION',
                { existsErrorCode: 955, critical: true }, // ORA-00955: name is already used by an existing object
            ),
        )

        // 2. Операції: Коментарі до таблиці
        if (tableDef.tableComment) {
            operations.push(
                createOperation(
                    `COMMENT_TABLE_${tableName}`,
                    generateTableCommentSQL(tableName, tableDef.tableComment),
                    'TABLE_COMMENT',
                    { critical: false }, // Коментарі не є критичними для функціональності
                ),
            )
        }

        // 3. Операції: Коментарі до стовпців
        for (const column of tableDef.columns) {
            if (column.comment) {
                operations.push(
                    createOperation(
                        `COMMENT_COLUMN_${tableName}_${column.name}`,
                        generateColumnCommentSQL(tableName, column.name, column.comment),
                        'COLUMN_COMMENT',
                        { critical: false },
                    ),
                )
            }
        }

        // 4. Операції: Додаткові індекси (не ті, що створені PK/UNIQUE)
        for (const indexDef of tableDef.indexes) {
            operations.push(
                createOperation(
                    indexDef.name,
                    generateCreateIndexSQL(tableName, indexDef),
                    'INDEX_CREATION',
                    { existsErrorCode: 955, critical: true },
                ),
            )
        }
    }

    // TODO: Якщо ви додасте інші типи об'єктів (views, sequences тощо)
    // Додайте тут логіку для їх генерації та додавання до масиву operations

    return operations
}
