Архітектура WebSocket-сервера: Масштабованість та Ефективність
Цей документ підсумовує ключові архітектурні рішення, які необхідно враховувати для побудови максимально ефективної та горизонтально масштабованої системи на WebSocket.
Розроблена нами система використовує гібридний підхід: локальний стан для швидкості та централізовані сервіси (Pub/Sub та БД) для узгодженості та масштабування.

1. Горизонтальне масштабування (Horizontal Scaling)
Критично важливим є можливість запускати кілька незалежних процесів сервера (інстансів) за балансувальником навантаження.
Ключові елементи:
Stateless інстанси: Самі інстанси сервера не повинні зберігати критичний глобальний стан (наприклад, історію повідомлень чи стан гри). Вони зберігають лише ефемерний локальний стан (які клієнти підключені саме до них).
Балансувальник навантаження (Load Balancer): Необхідний для розподілу вхідних з'єднань між інстансами. Він має підтримувати "липкі сесії" (sticky sessions), гарантуючи, що конкретний клієнт завжди перепідключається до того самого інстанса.

2. Комунікація між інстансами (Inter-Instance Communication)
Для синхронізації подій між інстансами використовується брокер повідомлень (наприклад, Redis Pub/Sub).
Ключові елементи:
Шаблон Pub/Sub: Інстанси підписуються на канали (наприклад, ws:chat, ws:game). Коли на одному інстансі відбувається подія, яка має бути глобальною, він публікує її в брокер.
Гібридна розсилка (Hybrid Broadcast):
Повідомлення розсилається локально (на поточному інстансі) для мінімізації затримки.
Повідомлення публікується в брокер для розсилки на інші інстанси.
Уникнення зациклення (instanceId, excludeId): Кожне повідомлення Pub/Sub містить унікальний ID сервера-відправника та ID клієнта-відправника. Інстанси ігнорують повідомлення, що повертаються від них самих, запобігаючи нескінченним циклам і подвійним повідомленням для клієнтів.

3. Управління станом (State Management)
Стан системи ділиться на два типи:
A. Локальний стан (Ephemeral State)
Що: Інформація про активні WebSocket-з'єднання, локальні підписки на кімнати, статус "живий" (isAlive).
Де: Зберігається виключно в оперативній пам'яті (RAM) інстанса, що обслуговує клієнта (використовуються класи WebSocketConnection, WebSocketRoom).
Мета: Швидкість та ефективність обробки локальних подій.
B. Глобальний стан (System State)
Що: Історія повідомлень чату, стан ігрової сесії, загальна кількість користувачів онлайн, дані профілів.
Де: Зберігається в централізованій, стійкій базі даних (PostgreSQL, Redis, MongoDB).
Мета: Гарантія узгодженості даних між усіма інстансами, збереження даних при перезавантаженні інстанса.

4. Гнучкість та Впровадження залежностей (Dependency Injection)
Для підтримки універсальності та легкої заміни компонентів використовується DI.
Ключові елементи:
Абстрактні інтерфейси: Класи ядра (WsServerManager, WebSocketNamespace) не містять специфічного коду для Redis чи PostgreSQL. Вони працюють з абстрактними адаптерами (DatabaseAdapter, PubSubBroker).
Зовнішня конфігурація: Реалізації адаптерів (наприклад, InMemoryBroker для тестів або RedisBroker для продакшну) передаються ззовні під час ініціалізації сервера (server.js).

5. Запобігання витокам пам'яті та Надійність
Heartbeat (Ping/Pong): Регулярні перевірки активності з'єднань дозволяють ідентифікувати та примусово закривати "мертві" сокети, запобігаючи витоку пам'яті.
Повне очищення: При закритті з'єднання важливо видаляти ID клієнта з усіх локальних колекцій (#connections, #subscriptions, #rooms), а також оновлювати стан присутності в центральній БД.
