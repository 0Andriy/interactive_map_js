<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>Infinite Engine V16 - Final Restored</title>
    <style>
        :root {
            --bg: #050508;
            --accent: #38bdf8;
            --panel: rgba(15, 23, 42, 0.95);
            --border: rgba(56, 189, 248, 0.3);
            --text: #f1f5f9;
        }

        body, html { margin: 0; overflow: hidden; height: 100%; background: var(--bg); color: var(--text); font-family: 'Inter', sans-serif; }
        body.panning { user-select: none; }

        #viewport { width: 100vw; height: 100vh; cursor: crosshair; position: relative; overflow: hidden; }
        canvas { position: absolute; inset: 0; pointer-events: none; }
        #content-layer { position: absolute; transform-origin: 0 0; pointer-events: none; }

        /* UI WRAPPER */
        .ui-wrapper { position: fixed; top: 24px; left: 24px; z-index: 1000; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .ui-panel {
            min-width: 44px; min-height: 44px; background: var(--panel); backdrop-filter: blur(16px);
            border: 1px solid var(--border); border-radius: 22px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: all 0.3s ease; position: relative; display: flex; flex-direction: column; overflow: hidden;
        }

        .ui-wrapper.collapsed .ui-panel { width: 44px; height: 44px; justify-content: center; align-items: center; }
        .ui-wrapper.collapsed:hover .ui-panel, .ui-wrapper.pinned .ui-panel { width: 260px; height: auto; padding: 20px; border-radius: 20px; }

        .menu-trigger { font-size: 20px; display: none; cursor: pointer; }
        .ui-wrapper.collapsed .menu-trigger { display: block; }
        
        .panel-content { opacity: 1; width: 100%; }
        .ui-wrapper.collapsed .panel-content { opacity: 0; display: none; }
        .ui-wrapper.collapsed:hover .panel-content, .ui-wrapper.pinned .panel-content { opacity: 1; display: block; }

        .pin-btn { position: absolute; top: 12px; right: 12px; background: none; border: none; cursor: pointer; color: var(--accent); font-size: 16px; }

        .title { font-weight: 800; font-size: 11px; color: var(--accent); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
        .control { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; font-size: 13px; cursor: pointer; }
        .control input { accent-color: var(--accent); width: 16px; height: 16px; }
        .divider { height: 1px; background: var(--border); margin: 16px 0; }
        .stats { font-family: monospace; font-size: 10px; opacity: 0.5; margin-top: 15px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px; line-height: 1.5; }

        /* –û–ë'–Ñ–ö–¢–ò */
        .map-card {
            position: absolute; pointer-events: auto;
            background: linear-gradient(135deg, #1e293b, #0f172a);
            border: 1px solid var(--border); padding: 12px 16px; border-radius: 12px;
            cursor: move; transform: translate(-50%, -50%); user-select: none;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4); min-width: 140px;
        }
        .map-card[data-group="base"] { border-left: 4px solid var(--accent); }
        .map-card[data-group="note"] { border-left: 4px solid #fbbf24; }
        .map-card b { color: var(--accent); font-size: 13px; display: block; margin-bottom: 4px; }
        .map-card small { font-size: 9px; opacity: 0.5; font-family: monospace; }
        .map-card.dragging { opacity: 0.7; scale: 1.05; border-style: dashed; z-index: 1000; }
    </style>
</head>
<body>

<div class="ui-wrapper collapsed" id="uiWrapper">
    <div class="ui-panel">
        <div class="menu-trigger">‚öôÔ∏è</div>
        <div class="panel-content">
            <button class="pin-btn" id="pinBtn">üìå</button>
            <div class="title">–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è</div>
            <label class="control"><input type="checkbox" id="showGrid" checked> –°—ñ—Ç–∫–∞</label>
            <label class="control"><input type="checkbox" id="showLabels" checked> –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏</label>
            <label class="control"><input type="checkbox" id="useBounds"> –ú–µ–∂—ñ —Å–≤—ñ—Ç—É</label>
            <div class="divider"></div>
            <div class="title">–ì—Ä—É–ø–∏</div>
            <label class="control"><input type="checkbox" id="group-base" checked> –°—Ç–∞–Ω—Ü—ñ—ó</label>
            <label class="control"><input type="checkbox" id="group-note" checked> –ù–æ—Ç–∞—Ç–∫–∏</label>
            <div class="stats" id="stats"></div>
        </div>
    </div>
</div>

<div id="viewport">
    <canvas id="gridCanvas"></canvas>
    <div id="content-layer"></div>
</div>

<script>
const ENGINE = {
    state: { x: innerWidth / 2, y: innerHeight / 2, zoom: 1.0, isPanning: false, draggedObj: null },
    ui: { showGrid: true, showLabels: true, useBounds: false, isPinned: false, groups: { base: true, note: true } },
    objects: [],
    config: {
        grid: { step: 100, base: 2, colors: { major: 'rgba(56, 189, 248, 0.3)', axes: '#38bdf8' }},
        camera: { min: 0.005, max: 100, speed: 0.0012 },
        bounds: { x: [-5000, 5000], y: [-4000, 4000] },
        geo: { pps: 500 } // pixels per degree
    },
    utils: {
        toGeo(wx, wy) {
            return { lat: -(wy / ENGINE.config.geo.pps).toFixed(4), lng: (wx / ENGINE.config.geo.pps).toFixed(4) };
        },
        clamp(tx, ty, z) {
            if (!ENGINE.ui.useBounds) return { x: tx, y: ty };
            const b = ENGINE.config.bounds, sw = innerWidth, sh = innerHeight;
            const minX = sw - b.x[1]*z, maxX = -b.x[0]*z, minY = sh - b.y[1]*z, maxY = -b.y[0]*z;
            return {
                x: minX > maxX ? (minX + maxX)/2 : Math.max(minX, Math.min(tx, maxX)),
                y: minY > maxY ? (minY + maxY)/2 : Math.max(minY, Math.min(ty, maxY))
            };
        },
        save() {
            localStorage.setItem('map_objs', JSON.stringify(ENGINE.objects));
            localStorage.setItem('map_ui', JSON.stringify(ENGINE.ui));
        },
        load() {
            const o = localStorage.getItem('map_objs'), u = localStorage.getItem('map_ui');
            ENGINE.objects = o ? JSON.parse(o) : [{ id: 1, x: 0, y: 0, title: "–¶–µ–Ω—Ç—Ä", group: "base" }];
            if (u) {
                ENGINE.ui = JSON.parse(u);
                if (ENGINE.ui.isPinned) { uiWrapper.classList.replace('collapsed', 'pinned'); pinBtn.innerText = 'üìç'; }
                document.getElementById('showGrid').checked = ENGINE.ui.showGrid;
                document.getElementById('showLabels').checked = ENGINE.ui.showLabels;
                document.getElementById('useBounds').checked = ENGINE.ui.useBounds;
                document.getElementById('group-base').checked = ENGINE.ui.groups.base;
                document.getElementById('group-note').checked = ENGINE.ui.groups.note;
            }
        }
    }
};

const canvas = document.getElementById('gridCanvas'), ctx = canvas.getContext('2d');
const contentLayer = document.getElementById('content-layer'), viewport = document.getElementById('viewport');

function render() {
    const { state, ui } = ENGINE;
    contentLayer.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.zoom})`;
    
    // –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ —Ä–µ–Ω–¥–µ—Ä –æ–±'—î–∫—Ç—ñ–≤ –∑ –ü–ö–ú —Ç–∞ Drag
    contentLayer.innerHTML = ENGINE.objects.filter(o => ui.groups[o.group]).map(o => {
        const geo = ENGINE.utils.toGeo(o.x, o.y);
        return `
            <div class="map-card ${state.draggedObj?.id === o.id ? 'dragging' : ''}" 
                 data-group="${o.group}" style="left:${o.x}px; top:${o.y}px" 
                 onmousedown="event.stopPropagation(); ENGINE.state.draggedObj = ENGINE.objects.find(i => i.id === ${o.id})"
                 oncontextmenu="event.preventDefault(); ENGINE.objects = ENGINE.objects.filter(i => i.id !== ${o.id}); ENGINE.utils.save(); render()">
                <b>${o.title}</b>
                <small>LAT: ${geo.lat} | LNG: ${geo.lng}</small>
            </div>
        `;
    }).join('');

    drawGrid();
    const cGeo = ENGINE.utils.toGeo((innerWidth/2-state.x)/state.zoom, (innerHeight/2-state.y)/state.zoom);
    document.getElementById('stats').innerHTML = `ZOOM: ${state.zoom.toFixed(3)}<br>LAT: ${cGeo.lat}<br>LNG: ${cGeo.lng}`;
}

function drawGrid() {
    canvas.width = innerWidth; canvas.height = innerHeight;
    const { state, config, ui } = ENGINE;
    if (!ui.showGrid && !ui.showLabels) return;

    const logB = config.grid.base, exp = Math.log(state.zoom) / Math.log(logB);
    const fExp = Math.floor(exp), frac = exp - fExp;
    const step = config.grid.step * Math.pow(logB, -fExp);
    const next = step * logB;

    drawLayer(step, (1 - frac) * 0.25, ui.showLabels && frac < 0.6);
    drawLayer(next, frac * 0.25, ui.showLabels && frac >= 0.6);

    if (ui.showGrid) {
        ctx.beginPath(); ctx.strokeStyle = config.grid.colors.axes; ctx.lineWidth = 2; ctx.globalAlpha = 0.4;
        if (state.x > 0 && state.x < canvas.width) { ctx.moveTo(state.x, 0); ctx.lineTo(state.x, canvas.height); }
        if (state.y > 0 && state.y < canvas.height) { ctx.moveTo(0, state.y); ctx.lineTo(canvas.width, state.y); }
        ctx.stroke(); ctx.globalAlpha = 1.0;
    }
}

function drawLayer(step, opacity, show) {
    const scaled = step * ENGINE.state.zoom;
    if (scaled < 8 || opacity <= 0) return;
    ctx.beginPath();
    ctx.strokeStyle = ENGINE.ui.showGrid ? `rgba(56, 189, 248, ${opacity})` : 'transparent';
    ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 2})`;
    ctx.font = "10px monospace";
    for (let i = ENGINE.state.x % scaled; i < canvas.width; i += scaled) {
        const x = Math.round(i)-0.5; ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height);
        if (show && scaled > 60) ctx.fillText(Math.round((i - ENGINE.state.x)/ENGINE.state.zoom), i+4, 15);
    }
    for (let j = ENGINE.state.y % scaled; j < canvas.height; j += scaled) {
        const y = Math.round(j)-0.5; ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
        if (show && scaled > 60) ctx.fillText(Math.round((j - ENGINE.state.y)/ENGINE.state.zoom), 4, j-4);
    }
    ctx.stroke();
}

// EVENTS
const uiWrapper = document.getElementById('uiWrapper'), pinBtn = document.getElementById('pinBtn');
pinBtn.onclick = (e) => {
    e.stopPropagation();
    ENGINE.ui.isPinned = !ENGINE.ui.isPinned;
    uiWrapper.classList.toggle('pinned', ENGINE.ui.isPinned);
    uiWrapper.classList.toggle('collapsed', !ENGINE.ui.isPinned);
    pinBtn.innerText = ENGINE.ui.isPinned ? 'üìç' : 'üìå';
    ENGINE.utils.save();
};

viewport.ondblclick = (e) => {
    if (e.target !== viewport && e.target !== canvas) return;
    const wx = (e.clientX - ENGINE.state.x) / ENGINE.state.zoom;
    const wy = (e.clientY - ENGINE.state.y) / ENGINE.state.zoom;
    const t = prompt("–ù–∞–∑–≤–∞ –æ–±'—î–∫—Ç–∞:");
    if (t) { ENGINE.objects.push({ id: Date.now(), x: wx, y: wy, title: t, group: "note" }); ENGINE.utils.save(); render(); }
};

viewport.onwheel = e => {
    e.preventDefault();
    const s = ENGINE.state, c = ENGINE.config.camera;
    const oldZ = s.zoom, newZ = Math.max(c.min, Math.min(oldZ * (1 - e.deltaY * c.speed), c.max));
    const r = newZ / oldZ;
    const p = ENGINE.utils.clamp(e.clientX - (e.clientX - s.x) * r, e.clientY - (e.clientY - s.y) * r, newZ);
    Object.assign(s, { x: p.x, y: p.y, zoom: newZ }); render();
};

// –î–æ–¥–∞–π—Ç–µ —Ü–µ–π –æ–±—Ä–æ–±–Ω–∏–∫ —É –∫—ñ–Ω–µ—Ü—å –±–ª–æ–∫—É EVENTS
viewport.addEventListener('mousemove', (e) => {
    // –í–∏—Ä–∞—Ö–æ–≤—É—î–º–æ "—Å–≤—ñ—Ç–æ–≤—ñ" –ø—ñ–∫—Å–µ–ª—ñ –ø—ñ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
    const worldX = (e.clientX - ENGINE.state.x) / ENGINE.state.zoom;
    const worldY = (e.clientY - ENGINE.state.y) / ENGINE.state.zoom;
    
    // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ —É Geo
    const geo = ENGINE.utils.toGeo(worldX, worldY);
    
    // –í–∏–≤–æ–¥–∏–º–æ –≤ –∫–æ–Ω—Å–æ–ª—å –∞–±–æ –≤ –æ–∫—Ä–µ–º–∏–π –±–ª–æ–∫ (–æ–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ)
    console.log(`Cursor World: ${Math.round(worldX)}:${Math.round(worldY)} | Geo: ${geo.lat}, ${geo.lng}`);
});

window.onmousemove = e => {
    const s = ENGINE.state;
    if (s.draggedObj) { s.draggedObj.x += e.movementX/s.zoom; s.draggedObj.y += e.movementY/s.zoom; render(); }
    else if (s.isPanning) { const p = ENGINE.utils.clamp(s.x + e.movementX, s.y + e.movementY, s.zoom); Object.assign(s, p); render(); }
};

window.onmousedown = (e) => { if(e.target === viewport || e.target === canvas) { ENGINE.state.isPanning = true; document.body.classList.add('panning'); }};
window.onmouseup = () => { if (ENGINE.state.draggedObj) ENGINE.utils.save(); ENGINE.state.isPanning = false; ENGINE.state.draggedObj = null; document.body.classList.remove('panning'); render(); };
window.oncontextmenu = e => e.preventDefault();

document.querySelectorAll('input').forEach(el => el.onchange = e => {
    if (e.target.id.startsWith('group-')) ENGINE.ui.groups[e.target.id.replace('group-', '')] = e.target.checked;
    else ENGINE.ui[e.target.id] = e.target.checked;
    ENGINE.utils.save(); render();
});

ENGINE.utils.load();
window.onresize = render;
render();
</script>
</body>
</html>
