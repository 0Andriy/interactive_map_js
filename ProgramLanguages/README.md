# Патерни проектування (Design Patterns)

Патерни проектування — це загальновизнані рішення для вирішення типових проблем у розробці програмного забезпечення. Вони не є конкретним фрагментом коду, а скоріше шаблонами, які можна адаптувати до різних ситуацій.

Цей репозиторій містить опис та приклади застосування популярних патернів проектування, які можуть бути корисними для розробників, що хочуть покращити якість свого коду та зробити його більш гнучким і підтримуваним.

## Зміст

-   [Вступ](#вступ)
-   [Типи патернів проектування](#типи-патернів-проектування)
    -   [Патерни створення](#патерни-створення)
    -   [Патерни структури](#патерни-структури)
    -   [Патерни поведінки](#патерни-поведінки)
-   [Рейтинг популярних патернів](#рейтинг-популярних-патернів)
-   [Приклади використання](#приклади-використання)
-   [Поради щодо використання патернів](#поради-щодо-використання-патернів)
-   [Література та ресурси](#література-та-ресурси)

## Вступ

Патерни проектування дозволяють спростити розробку програмного забезпечення, зменшити кількість помилок, підвищити зручність для інших розробників та зробити систему більш модульною. Вони забезпечують перевірені рішення для стандартних задач, а також дозволяють підтримувати єдність стилю програмування у команді.

## Типи патернів проектування

### Патерни створення

Патерни цього типу вирішують проблеми, пов'язані з створенням об'єктів. Вони визначають механізм створення об'єктів, який не залежить від того, як саме вони реалізовані.

1. **Singleton** — забезпечує існування лише одного екземпляра класу.

    - **Коли використовувати**: Якщо потрібно, щоб клас мав лише один екземпляр у системі, наприклад, у випадках, коли єдиний доступ до ресурсу або налаштування повинні бути централізованими, наприклад, для логування, доступу до бази даних або налаштувань програми.
    - **Приклад використання**: Конфігурація, логгер, кешування, менеджер подій.

2. **Factory Method** — дозволяє створювати об'єкти без зазначення точного класу.

    - **Коли використовувати**: Коли потрібно створювати об'єкти без конкретизації класу. Це зручно, коли є багато різних реалізацій одного інтерфейсу або абстракції.
    - **Приклад використання**: Створення різних типів документів у програмі текстового процесора.

3. **Abstract Factory** — створює родини об'єктів без визначення конкретних класів.

    - **Коли використовувати**: Якщо система повинна працювати з кількома сімействами об'єктів, але потрібно забезпечити їхню сумісність.
    - **Приклад використання**: Кросплатформенне програмне забезпечення, де одна фабрика може створювати об'єкти для різних операційних систем.

4. **Builder** — полегшує створення складних об'єктів.

    - **Коли використовувати**: Коли потрібно створювати складні об'єкти поетапно, і коли конструкція цього об'єкта потребує кількох кроків, що можуть бути виконані в різному порядку.
    - **Приклад використання**: Створення складних об'єктів, таких як документи, налаштування або навіть HTML-сторінки.

5. **Prototype** — дозволяє створювати нові об'єкти на основі існуючих.
    - **Коли використовувати**: Коли потрібно створювати нові об'єкти, які є копіями інших об'єктів, і коли ці об'єкти можуть бути дорогими в створенні.
    - **Приклад використання**: Копіювання документів, об'єктів налаштувань тощо.

### Патерни структури

Ці патерни описують, як організувати класи та об'єкти таким чином, щоб вони могли взаємодіяти між собою і працювати більш ефективно.

1. **Adapter** — дозволяє класам з несумісними інтерфейсами працювати разом.

    - **Коли використовувати**: Коли потрібно інтегрувати код з бібліотеками або компонентами, які не мають однакових інтерфейсів, або коли існуючий код не підходить для вашої системи.
    - **Приклад використання**: Інтеграція сторонніх бібліотек з вашим кодом.

2. **Composite** — дозволяє обробляти окремі об'єкти та їх композиції однаково.

    - **Коли використовувати**: Коли треба працювати з об'єктами, які можуть бути складеними структурами, наприклад, з деревоподібними ієрархіями.
    - **Приклад використання**: Створення складних елементів інтерфейсу або моделювання файлової системи.

3. **Decorator** — додає нову поведінку до об'єкта без зміни його класу.

    - **Коли використовувати**: Якщо потрібно динамічно змінювати або додавати поведінку об'єкта без зміни його коду.
    - **Приклад використання**: Додавання функціональності, наприклад, до візуальних компонентів інтерфейсу користувача.

4. **Facade** — надає спрощений інтерфейс для складної системи.

    - **Коли використовувати**: Якщо система є дуже складною і ви хочете надати спрощений інтерфейс для взаємодії з нею.
    - **Приклад використання**: Спрощення доступу до складних бібліотек чи API.

5. **Flyweight** — зменшує кількість створюваних об'єктів, використовуючи спільні ресурси.

    - **Коли використовувати**: Якщо потрібно ефективно зберігати велику кількість об'єктів, які мають спільні характеристики.
    - **Приклад використання**: Створення графічних елементів, які мають однакові властивості, але використовують спільні ресурси.

6. **Proxy** — дозволяє обробляти доступ до об'єктів, контроль за якими потрібен.
    - **Коли використовувати**: Якщо потрібно контролювати доступ до об'єктів або обмежити доступ до них з певними перевірками.
    - **Приклад використання**: Управління доступом до віддалених об'єктів або кешування даних.

### Патерни поведінки

Ці патерни описують взаємодію об'єктів і як вони виконують певні задачі, щоб забезпечити ефективну комунікацію.

1. **Observer** — дозволяє одразу сповіщати всі залежні об'єкти про зміни в іншому об'єкті.

    - **Коли використовувати**: Якщо потрібно, щоб декілька об'єктів отримували сповіщення про зміни в іншому об'єкті.
    - **Приклад використання**: Реалізація подій у графічних інтерфейсах користувача або оновлення даних у реальному часі.

2. **Strategy** — дозволяє вибирати алгоритм на виконання під час роботи програми.

    - **Коли використовувати**: Якщо є кілька варіантів алгоритмів, і потрібно вибирати між ними в залежності від контексту.
    - **Приклад використання**: Використання різних алгоритмів сортування в залежності від розміру масиву.

3. **Command** — перетворює запит на об'єкт, який можна виконати пізніше.

    - **Коли використовувати**: Якщо потрібно запаковувати запити як об'єкти, щоб зберігати, передавати або виконувати їх пізніше.
    - **Приклад використання**: Використання в командних інтерфейсах, де кожна команда може бути запам'ятована і виконана пізніше.

4. **Chain of Responsibility** — дозволяє обробляти запит через послідовність обробників.

    - **Коли використовувати**: Якщо потрібно, щоб запит оброблявся послідовністю обробників, де кожен може обробити запит або передати його далі.
    - **Приклад використання**: Обробка помилок або логування в різних частинах системи.

5. **State** — дозволяє змінювати поведінку об'єкта залежно від його стану.

    - **Коли використовувати**: Якщо об'єкт повинен змінювати свою поведінку в залежності від поточного стану.
    - **Приклад використання**: Автоматичні апарати, де кожен стан має свою поведінку.

6. **Template Method** — визначає кроки алгоритму в методі, дозволяючи підкласам змінювати певні кроки.

    - **Коли використовувати**: Якщо алгоритм є певним і ви хочете дозволити підкласам змінювати деякі частини цього алгоритму.
    - **Приклад використання**: Шаблонні алгоритми для обробки даних, де підкласи можуть визначати специфічні кроки.

7. **Visitor** — дозволяє додавати нову поведінку до об'єктів, не змінюючи їх.
    - **Коли використовувати**: Якщо потрібно додавати нові операції для об'єктів без змінювання їхнього коду.
    - **Приклад використання**: Обробка різних типів елементів у колекціях, наприклад, підрахунок вартості товарів у кошику.

## Рейтинг популярних патернів

| Патерн         | Категорія | Опис                                         | Популярність |
| -------------- | --------- | -------------------------------------------- | ------------ |
| Singleton      | Створення | Забезпечує існування лише одного екземпляра. | Висока       |
| Factory Method | Створення | Створює об'єкти через абстракцію.            | Висока       |
| Observer       | Поведінка | Сповіщає об'єкти про зміни в іншому об'єкті. | Висока       |
| Adapter        | Структура | Перетворює інтерфейси для сумісності.        | Висока       |
| Decorator      | Структура | Додає нову поведінку до об'єкта.             | Середня      |

## Поради щодо використання патернів

1. Не слід застосовувати патерни без потреби — вони можуть збільшити складність вашої програми, якщо їх використовувати невиправдано.
2. Патерни повинні адаптуватися до конкретної ситуації та вимог, щоб бути корисними.
3. Вибір патерну повинен базуватися на потребах проекту та умовах його реалізації.

## Приклади використання

### 1. Singleton

```python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

singleton1 = Singleton()
singleton2 = Singleton()

print(singleton1 is singleton2)  # True
```

```javascript
class Singleton {
    instance = null

    constructor() {
        if (Singleton.instance) {
            return Singleton.instance
        }

        Singleton.instance = this
        this.data = 'Some important data'
    }

    getData() {
        return this.data
    }
}

const instance1 = new Singleton()
const instance2 = new Singleton()

console.log(instance1 === instance2) // true
```
